{"ast":null,"code":"import { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { FiClock, FiCalendar, FiUser } from 'react-icons/fi';\nimport Link from 'next/link';\nimport Prismic from '@prismicio/client';\nimport { getPrismicClient } from '../../services/prismic';\nimport { RichText } from \"prismic-dom\";\nimport { format } from 'date-fns';\nimport ptBR from 'date-fns/locale/pt-BR';\nimport styles from './post.module.scss';\nimport { useRouter } from 'next/router';\nimport Comments from '../../components/Comments';\nimport { PostNavigator } from '../../components/PostNavigator/PostNavigator';\nexport default function Post({\n  post,\n  preview,\n  previousPost,\n  nextPost\n}) {\n  const router = useRouter();\n\n  if (router.isFallback) {\n    return /*#__PURE__*/_jsx(\"h1\", {\n      children: \"Carregando...\"\n    });\n  }\n\n  const publicatedAt = format(new Date(post.first_publication_date), 'dd MMM yyyy', {\n    locale: ptBR\n  });\n  const updatedAt = format(new Date(post.last_publication_date), 'dd MMM yyyy', {\n    locale: ptBR\n  });\n  const updatedAtHours = format(new Date(post.last_publication_date), \"kk:mm\", {\n    locale: ptBR\n  });\n  const wordsNumber = post.data.content.map(item => {\n    const text = RichText.asText(item.body);\n    const aux = [];\n    const arr = text.split(' ');\n    const arrConcat = aux.concat(arr).length;\n    return arrConcat;\n  });\n  const readTime = wordsNumber.reduce((acc, item) => {\n    const total = acc + item;\n    const time = Math.ceil(total / 200);\n    return time;\n  }, 0);\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsx(\"div\", {\n      className: styles.banner,\n      children: /*#__PURE__*/_jsx(\"img\", {\n        src: post.data.banner.url,\n        alt: \"banner\"\n      })\n    }), /*#__PURE__*/_jsxs(\"main\", {\n      className: styles.container,\n      children: [/*#__PURE__*/_jsx(\"h1\", {\n        children: post.data.title\n      }), /*#__PURE__*/_jsxs(\"section\", {\n        children: [/*#__PURE__*/_jsx(FiCalendar, {}), publicatedAt, /*#__PURE__*/_jsx(FiUser, {}), post.data.author, /*#__PURE__*/_jsx(FiClock, {}), readTime, \" min\"]\n      }), updatedAt !== publicatedAt && /*#__PURE__*/_jsxs(\"p\", {\n        className: styles.updatedAt,\n        children: [\"* editado em \", updatedAt, \", \\xE0s \", updatedAtHours]\n      }), post.data.content.map(item => {\n        return /*#__PURE__*/_jsxs(\"article\", {\n          className: styles.content,\n          children: [/*#__PURE__*/_jsx(\"h2\", {\n            children: item.heading\n          }), /*#__PURE__*/_jsx(\"div\", {\n            dangerouslySetInnerHTML: {\n              __html: RichText.asHtml(item.body)\n            }\n          })]\n        }, item.heading);\n      }), /*#__PURE__*/_jsx(\"div\", {\n        className: styles.wrapper\n      }), /*#__PURE__*/_jsx(PostNavigator, {\n        previous: previousPost,\n        next: nextPost\n      }), /*#__PURE__*/_jsx(Comments, {}), preview && /*#__PURE__*/_jsx(\"aside\", {\n        className: styles.preview,\n        children: /*#__PURE__*/_jsx(Link, {\n          href: \"/api/exitPreview\",\n          children: /*#__PURE__*/_jsx(\"a\", {\n            children: \"Sair do modo Preview\"\n          })\n        })\n      })]\n    })]\n  });\n}\nexport const getStaticPaths = async () => {\n  const prismic = getPrismicClient();\n  const posts = await prismic.query([Prismic.predicates.at('document.type', 'post')]);\n  const paths = posts.results.map(post => {\n    return {\n      params: {\n        slug: post.uid\n      }\n    };\n  });\n  return {\n    paths,\n    fallback: true\n  };\n};\nexport const getStaticProps = async ({\n  params,\n  preview = false,\n  previewData\n}) => {\n  var _previewData$ref;\n\n  const prismic = getPrismicClient();\n  const {\n    slug\n  } = params;\n  const response = await prismic.getByUID('post', String(slug), {\n    ref: (_previewData$ref = previewData === null || previewData === void 0 ? void 0 : previewData.ref) !== null && _previewData$ref !== void 0 ? _previewData$ref : null\n  });\n  const post = {\n    uid: response.uid,\n    first_publication_date: response.first_publication_date,\n    last_publication_date: response.last_publication_date,\n    data: {\n      title: response.data.title,\n      author: response.data.author,\n      banner: {\n        url: response.data.banner.url\n      },\n      content: response.data.content.map(content => {\n        return {\n          heading: content.heading,\n          body: [...content.body]\n        };\n      })\n    }\n  };\n  let previousPost = null;\n  let nextPost = null;\n  const responsePreviousPost = await prismic.query([Prismic.predicates.at('document.type', 'post'), Prismic.predicates.dateAfter('document.first_publication_date', post.first_publication_date)], {\n    fetch: ['posts.title'],\n    pageSize: 1,\n    page: 1\n  });\n\n  if (responsePreviousPost.results.length) {\n    var _responsePreviousPost;\n\n    previousPost = {\n      uid: responsePreviousPost.results[0].uid,\n      title: (_responsePreviousPost = responsePreviousPost.results[0].data) === null || _responsePreviousPost === void 0 ? void 0 : _responsePreviousPost.title\n    };\n  }\n\n  const responseNextPost = await prismic.query([Prismic.predicates.at('document.type', 'post'), Prismic.predicates.dateBefore('document.first_publication_date', post.first_publication_date)], {\n    fetch: ['posts.title'],\n    pageSize: 1,\n    page: 1\n  });\n\n  if (responseNextPost.results.length) {\n    var _responseNextPost$res;\n\n    nextPost = {\n      uid: responseNextPost.results[0].uid,\n      title: (_responseNextPost$res = responseNextPost.results[0].data) === null || _responseNextPost$res === void 0 ? void 0 : _responseNextPost$res.title\n    };\n  }\n\n  return {\n    props: {\n      post,\n      previousPost,\n      nextPost,\n      preview\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module"}